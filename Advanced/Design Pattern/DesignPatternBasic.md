# Design Pattern (Basic)

> 작성자 : [배소라] (https://github.com/sorayayat)

<details>
<summary>목차</summary>

- [디자인 패턴란(Design Pattern)](#디자인-패턴이란)
- [1. 객체 지향의 특성 & 설계 원칙 & 디자인 패턴](#객체-지향의-특성--설계-원칙--디자인-패턴)
- [2. 디자인 패턴 종류](#디자인-패턴의-종류)



</details>

---

## 디자인 패턴이란?

시스템 디자인 시 특정 상황에서 반복되는 문제 패턴을 발견하고 문제에 대해 재사용이 가능한 해결책이다.
실제 비즈니스 요구 사항을 프로그래밍으로 처리하면서 만들어진 다양한 해결책 중에 많은 사람들이 인정한 **모범 사례(best practice)** 이다.


#### 장점

1. 재사용성 : 반복적인 문제에 대한 일반적인 해결책 제공으로 유사한 상황에서 보다 쉽게 작성이 가능

2. 가독성 : 일정하고 정리된 구조로 명확하게 작성하여 개발가 코드를 이해하고 유지보수가 용이

3. 유지보수 : 코드 모듈화하여 해당 모듈만 수정하여 유지보수에 용이

4. 확장성 : 새로운 기능을 추가, 변경할 때 기존 코드 변경없이 새로운 기능 통합이 가능

5. 안정성과 신뢰성 : 수 많은 사람들을 통한 모범 사례로 검증된 솔루션 제공

- 패턴을 사용함으로써 다른 개발자와 효율적으로 의사소통 할 수 있다는 장점을 가지고 있다.
디자인 패턴을 적용함으로써 문제에 대한 대비가 가능해진다.
---
### 객체 지향의 특성 & 설계 원칙 & 디자인 패턴

객체 지향의 특성 (캡슐화, 상속, 추상화, 다형성)이라는 도구를 올바르게 사용하기 위한 방법으로 설계 원칙(SOLID)이 있다.
도구와 도구 사용법을 알았다면 표준화된 방법으로 사용해야 한다.
(커다란 톱으로 대파를 썰지 않듯이)

---
### 디자인 패턴의 종류

가장 유명한 디자인 패턴으로는 GoF의 디자인 패턴에 대해 알아보자.

GoF의 디자인 패턴은 크게 **생성(Creational), 구조(Structural), 그리고 행위(Behavioral) 패턴**으로 분류된다.

#### 생성 패턴(Creational Pattern)

1. Singleton(싱글톤 패턴): 하나의 클래스 인스턴스를 전역에서 접근 가능하게 하면서 해당 인스턴스가 한 번만 생성되도록 보장하는 패턴이다.
2. Factory Method(팩토리 메서드 패턴) : 객체를 생성하기 위한 인터페이스를 정의하고, 서브클래스에서 어떤 클래스의 인스턴스를 생성할지 결정하는 패턴이다.
3. Abstract Factory(추상 팩토리 패턴) : 관련된 객체들의 집합을 생성하는 인터페이스를 제공하며, 구체적인 팩토리 클래스를 통해 객체 생성을 추상화하는 패턴이다.
4. Builder(빌더 패턴) : 복잡한 객체의 생성 과정을 단순화하고, 객체를 단계적으로 생성하며 구성하는 패턴이다.
5. Prototype(프로토타입 패턴): 객체를 복제하여 새로운 객체를 생성하는 패턴으로, 기존 객체를 템플릿으로 사용하는 패턴이다.

 
#### 구조 패턴(Structural Pattern)

1. Adapter(어댑터 패턴) : 인터페이스 호환성을 제공하지 않는 클래스를 사용하기 위해 래퍼(Wrapper)를 제공하는 패턴이다.
2. Bridge(브릿지 패턴) : 추상화와 구현을 분리하여 두 가지를 독립적으로 확장할 수 있는 패턴이다.
3. Composite(컴포지트 패턴) : 개별 객체와 복합 객체를 동일하게 다루어, 트리 구조의 객체를 구성하는 패턴이다.
4. Decorator(데코레이터 패턴) : 객체에 동적으로 새로운 기능을 추가하여 객체를 확장할 수 있는 패턴이다.
5. Facade(퍼사드 패턴) : 서브시스템을 더 쉽게 사용할 수 있도록 단순한 인터페이스를 제공하는 패턴이다.
6. Flyweight(플라이웨이트 패턴) : 공유 가능한 객체를 통해 메모리 사용을 최적화하는 패턴이다.
7. Proxy(프록시 패턴) : 다른 객체에 대한 대리자(Proxy)를 제공하여 접근 제어, 지연 로딩 등을 구현하는 패턴이다.

 
#### 행위 패턴(Behavioral Pattern)

1. Observer(옵저버 패턴) : 객체 간의 일대다 종속 관계를 정의하여 한 객체의 상태 변경이 다른 객체들에게 알려지도록 한다.
2. Strategy(전략 패턴) : 알고리즘을 정의하고, 실행 중에 선택할 수 있게 한다.
3. Command(커맨드 패턴) : 요청을 객체로 캡슐화하여 요청을 매개변수화 하고, 요청을 큐에 저장하거나 로깅하고 실행을 지연시킨다.
4. State(상태 패턴) : 객체의 상태를 캡슐화하고, 상태 전환을 관리한다.
5. Chain of Responsibility(책임 연쇄 패턴) : 요청을 보내는 객체와 이를 처리하는 객체를 분리하여, 다양한 처리자 중 하나가 요청을 처리한다.
6. Visitor(방문자 패턴) : 객체 구조를 순회하면서 다양한 연산을 수행할 수 있게 한다.
7. Interpreter(인터프리터 패턴) : 언어나 문법에 대한 해석기를 제공하여, 주어진 언어로 표현된 문제를 해결하는 패턴이다.
8. Memento(메멘토 패턴) : 객체의 내부 상태를 저장하고 복원할 수 있는 기능을 제공하는 패턴이다.
9. Mediator(중재자 패턴) : 객체 간의 상호 작용을 캡슐화하여, 객체 간의 직접적인 통신을 방지하는 패턴이다.
10. Template Method(템플릿 메서드 패턴) : 알고리즘의 구조를 정의하면서 하위 클래스에서 각 단계의 구현을 제공하는 디자인 패턴이다.
11. Iterator(이터레이터 패턴) : 컬렉션 내의 요소들에 접근하는 방법을 표준화하여 컬렉션의 내부 구조에 독립적으로 접근할 수 있는 패턴이다.

---

##### Singleton(싱글톤 패턴)

**단 하나의 유일한 객체를 만들기 위한** 코드 패턴이다.

싱글톤 패턴이 적용된 객체가 필요한 경우는 그 객체가 리소스를 많이 차지하는 역할을 하는 무거운 클래스일때 적합하다.  
우리가 전역 변수를 사용하는 이유는 똑같은 데이터를 매번 선언해서 사용하면 무의미하며 낭비가 때문에 전역에서 한번만 가져와 효율적으로 사용하기 위함이다.  
대표적으로 데이터베이스 연결 모듈을 예로 들 수 있다. db접속 작업은 그 자체로 무거운 작업에 속하며 굳이 여러번 생성할 필요가 없기 때문이다.  
이 밖에도 디스크 연결, 네트워크 통신, DBCP 커넥션풀, 스레드풀, 캐시, 로그 기록 객체 등에 이용된다. 
따라서 어플리케이션에서 유일해야 하며 유일한 것이 좋은 것을 싱글톤 객체로 만들면 된다. 

```
public class Singleton {
    // 자기 자신의 인스턴스를 private static 변수로 가집니다.
    private static Singleton instance;

    // 생성자를 private로 선언하여 외부에서 인스턴스를 생성하지 못하게 합니다.
    private Singleton() {}

    // 인스턴스를 반환하는 public static 메소드를 제공합니다.
    public static Singleton getInstance() {
        // 인스턴스가 null이면 생성합니다.
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}

```