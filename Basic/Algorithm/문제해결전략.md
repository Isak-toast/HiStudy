# 문제해결전략
> 작성자 : [김이삭](https://github.com/Isak-toast)

<details>
<summary>Table of Contents</summary>

- [문제 이해와 분석](#문제-이해와-분석)
- [알고리즘 설계 접근 방법](#알고리즘-설계-접근-방법)
- [코딩과 디버깅 전략](#코딩과-디버깅-전략)
- [성능 최적화](#성능-최적화)
- [실전문제 해결](#실전문제-해결)
- [부록 및 참고 자료](#부록-및-참고-자료)

</details>

---

## 문제 이해와 분석

### 문제 정의
문제를 풀기 위해선 먼저 무엇을 해결해야 하는지 정확히 알아야 합니다. 예를 들어, "정해진 숫자 목록에서 두 개의 숫자를 골라 그 합이 주어진 목표 숫자에 가장 가까운 조합을 찾아라" 같은 문제가 있다면, 중요한 부분은 '숫자 목록', '두 개의 숫자 고르기', '목표 숫자', '합이 목표에 가까운 조합 찾기'가 됩니다. 여기서 고려해야 할 제한 사항으로는 숫자 목록의 크기, 숫자의 범위, 같은 숫자를 어떻게 처리할지 등이 있겠죠.

![](https://blog.kakaocdn.net/dn/bUzUKB/btqxEiii0Uf/zJPkk3pCjtVRqOnsV9ufgk/img.png)

### 입력과 출력 분석
문제를 풀기 위해 무엇을 입력 받고, 무엇을 결과로 내보내야 하는지 명확히 알아야 합니다. 위 문제에서 입력은 숫자 목록과 목표 숫자이며, 출력은 두 숫자의 조합으로 그 합이 목표 숫자와 가장 가까워야 합니다. 입력과 출력을 확실히 이해함으로써 문제 해결의 출발점을 정할 수 있습니다.

![](https://velog.velcdn.com/images/yeah7598/post/d167fde2-8090-44c7-993a-67fae9f75315/image.png)

### 사례 분석
문제를 더 잘 이해하기 위해 몇 가지 예시를 들어보겠습니다.

예시 1: 숫자 목록이 `[-1, 2, 1, -4]`이고 목표 숫자가 `1`일 때, `[-1, 2]` (합이 1) 또는 `[1, -4]` (합이 `-3`)가 목표에 가까운 조합이 될 수 있습니다. 여기서 `[-1, 2]` 조합이 합이 `1`로 목표와 정확히 일치하기 때문에 가장 좋은 해답이 됩니다.

예시 2: 숫자 목록이 `[4, 0, 5, -5, 3, 3, 0, -4, -5]`이고 목표 숫자가 `-2`일 때, `[-5, 3]` 조합이 목표에 가까운 해답이 될 수 있습니다. 이 조합의 합은 `-2`로 목표 숫자와 일치합니다.

이런 예시들을 통해, 문제를 어떻게 풀지에 대한 아이디어를 얻을 수 있습니다. 예시를 분석하면서 문제의 복잡한 부분을 이해하고, 어떤 알고리즘(예: 숫자를 정렬한 후 두 포인터를 사용하는 방법)을 사용할 수 있을지 생각해 볼 수 있습니다. 또한, 특별한 경우나 조건(예: 같은 숫자 처리)을 찾아내고, 이를 해결하기 위한 방법을 고민해 볼 수 있습니다.

## 알고리즘 설계 접근 방법

### 문제 분해
문제 분해는 복잡한 문제를 더 작고, 다루기 쉬운 부분 문제로 나누는 전략입니다. 이 접근법은 문제를 분석하고 해결 방법을 찾는 데 있어 중요한 첫걸음입니다. 예를 들어, "피보나치 수열의 n번째 항을 찾는 문제"를 생각해봅시다. 이 문제는 두 개의 더 작은 피보나치 문제(즉, (n-1)번째 항과 (n-2)번째 항을 찾는 문제)로 나눌 수 있습니다. 이렇게 문제를 분해함으로써, 우리는 복잡한 문제를 해결할 수 있는 더 간단한 기반을 마련할 수 있습니다.

![](https://blog.kakaocdn.net/dn/I8DRV/btrnV21MS0R/RSG5VegF1VqUtoRslHohO0/img.png)

### 알고리즘 패턴 인식
알고리즘 패턴 인식은 재귀, 분할 정복, 동적 계획법 등과 같은 일반적인 알고리즘 설계 패턴을 식별하고, 이를 문제에 적용하는 능력입니다. 예를 들어, 앞서 언급한 피보나치 수열 문제는 재귀적인 패턴을 가지며, 이는 자연스럽게 재귀 알고리즘으로 해결할 수 있음을 시사합니다. 분할 정복 패턴은 문제를 분해하고 각 부분 문제를 해결한 뒤, 이 해결책을 결합하여 원래 문제의 해결책을 찾는 방법입니다. 동적 계획법은 중복 계산을 피하기 위해 이전에 계산한 결과를 저장하고 재사용하는 전략을 사용합니다.

![](https://user-images.githubusercontent.com/1250095/86745916-a62e9a00-c075-11ea-9aa5-8455e2527f87.png)

### 솔루션의 점진적 개선
문제 해결의 초기 단계에서는 단순하지만 비효율적인 해결책을 생각할 수 있습니다. 이후, 이러한 초기 해결책을 점진적으로 분석하고 개선하여, 더 효율적이고 우아한 솔루션을 찾아갑니다. 예를 들어, 피보나치 수열을 계산하는 초기 재귀 해결책은 많은 중복 계산을 포함할 수 있습니다. 이 문제를 인식한 후, 우리는 동적 계획법을 적용하여 중복 계산을 줄이고 효율성을 크게 향상시킬 수 있습니다. 또한, 더 나아가서 반복적인 방법으로 솔루션을 개선하여 재귀 호출에 따른 오버헤드를 제거할 수도 있습니다.

## 코딩과 디버깅 전략

### 의사 코드 작성
의사 코드 작성은 문제 해결 방법을 프로그래밍 언어가 아닌, 인간이 이해하기 쉬운 간단한 언어로 표현하는 과정입니다. 이는 알고리즘의 핵심 로직을 명확하게 하고, 복잡한 문제를 단계별로 나누어 생각하는 데 도움을 줍니다. 예를 들어, 정렬된 배열에서 특정 값의 위치를 찾는 이진 탐색 알고리즘의 의사 코드는 다음과 같이 간단하게 표현할 수 있습니다

```
이진 탐색(배열, 목표값):
    시작점 = 0
    끝점 = 배열의 길이 - 1

    반복 (시작점 <= 끝점):
        중간점 = (시작점 + 끝점) / 2의 내림
        만약 배열[중간점] == 목표값:
            반환 중간점
        그렇지 않고 배열[중간점] < 목표값:
            시작점 = 중간점 + 1
        그렇지 않으면:
            끝점 = 중간점 - 1

    반환 "목표값이 배열에 없음"
```

### 코드 구현
의사 코드를 바탕으로 실제 프로그래밍 언어를 사용해 알고리즘을 구현하는 단계입니다. 의사 코드는 구현할 로직의 틀을 제공하므로, 실제 코드를 작성할 때 논리적인 오류를 줄이고 효율적으로 작업할 수 있습니다. 이진 탐색 알고리즘의 의사 코드를 Python 코드로 변환하면 다음과 같습니다

```python
def binary_search(arr, target):
    start = 0
    end = len(arr) - 1

    while start <= end:
        mid = (start + end) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            start = mid + 1
        else:
            end = mid - 1

    return "Target not found in the array"
```

### 디버깅 기법
디버깅은 코드에서 버그나 오류를 찾아내고 수정하는 과정입니다. 효과적인 디버깅 전략은 시스템적으로 접근하는 것이 중요하며, 문제의 원인을 단계적으로 좁혀가는 방식으로 진행됩니다. 디버깅 과정에서는 다음과 같은 기법이 유용할 수 있습니다:

- 브레이크포인트 사용: 코드의 특정 지점에서 실행을 일시 중단하고, 변수의 값이나 프로그램의 상태를 검사합니다.
- 로깅: 코드의 다양한 지점에서 변수의 값이나 상태 변화를 출력하여, 프로그램의 실행 흐름을 추적합니다.
- 단위 테스트: 작은 코드 조각이나 함수가 예상대로 동작하는지 확인하기 위해 간단한 테스트 케이스를 작성하고 실행합니다.
- 러버덕 디버깅: 코드나 발생한 문제를 다른 사람에게 설명하는 과정에서 문제의 원인을 스스로 깨닫게 되는 경우가 많습니다. 실제로 누군가와 대화할 필요는 없으며, 단순히 문제를 소리 내어 설명하는 것만으로도 도움이 될 수 있습니다.

## 성능 최적화

### 효율성 분석
알고리즘의 성능을 평가하는 첫 단계는 `시간 복잡도와 공간 복잡도를 분석하는 것`입니다. 시간 복잡도는 알고리즘이 문제를 해결하는 데 필요한 시간을, 공간 복잡도는 필요한 메모리 공간을 나타냅니다. 예를 들어, 단순한 반복을 사용하는 선형 탐색 알고리즘은 시간 복잡도가
$O(n)$이고, 효율적인 이진 탐색은 $O(logn)$입니다. 효율성 분석을 통해 알고리즘이 입력 크기가 커질 때 어떻게 반응하는지 이해하고, 성능 병목을 식별할 수 있습니다.

![](https://blog.kakaocdn.net/dn/b1bjAK/btqZowNl8ui/0Pd9mOfKSRREt8LOKNVJ81/img.png)

### 리팩토링과 최적화
성능 분석을 바탕으로 코드를 리팩토링하고 알고리즘을 최적화하여 실행 속도를 높이고 메모리 사용을 줄일 수 있습니다. 리팩토링은 코드를 더 깔끔하고 효율적으로 만들면서도 그 기능을 유지하는 과정입니다. 예를 들어, 불필요한 반복문 제거, 더 효율적인 자료구조 사용, 중복 계산 방지 등이 이에 해당합니다. 최적화는 알고리즘의 핵심 로직을 개선하여 전체적인 성능을 향상시키는 작업입니다. 이 과정에서 프로파일링 도구를 사용하여 성능 개선 전후를 비교할 수 있습니다.

![](https://documentation.red-gate.com/app10/files/53936462/53936464/1/1526291764322/algorithm_results_5.png)

### 고급 최적화 기법
보다 복잡한 문제에 대해서는 고급 최적화 기법을 적용할 필요가 있습니다.

- 메모이제이션: 재귀적으로 문제를 해결할 때, 이전에 계산한 값을 저장하고 재사용함으로써 중복 계산을 방지합니다. 동적 계획법 문제에서 자주 사용됩니다.
- 탐욕적 기법: 매 선택에서 지금 당장 최적인 해를 선택해 나가면서 최종적으로 전체적인 최적해를 구하는 방식입니다. 하지만 모든 문제에 적용할 수 있는 것은 아니며, 문제가 탐욕적 선택 속성을 만족할 때 유효합니다.
- 휴리스틱 접근 방식: 완벽한 해를 찾는 것이 현실적으로 불가능할 때 사용되는 방법으로, 최적에 가까운 해를 효율적으로 찾습니다. 예를 들어, A* 탐색 알고리즘은 휴리스틱 함수를 사용하여 탐색 과정을 가이드합니다.

![](https://media.licdn.com/dms/image/C4E12AQEtD06ODcOAxA/article-cover_image-shrink_600_2000/0/1652693639101?e=2147483647&v=beta&t=6Jy4ps0ugKYXh8RcW_p3xHcIXYCRq8ZhWDXNjdXfKnI)
![](https://images.velog.io/images/falling_star3/post/f7a2947a-c953-40e2-a24e-20a50f5b3f49/%EB%8B%A4%EC%9A%B4%EB%A1%9C%EB%93%9C.png)

이러한 고급 기법들은 알고리즘의 효율성을 크게 향상시킬 수 있지만, 문제의 특성과 요구사항을 정확히 이해하고 적절히 적용할 필요가 있습니다. 때로는 이러한 기법들이 도입하는 추가적인 복잡성이 성능 개선의 이점을 상쇄할 수도 있으므로, 성능과 코드의 복잡성 사이에서 균형을 잘 맞추는 것이 중요합니다.

## 실전문제 해결
### 코딩 인터뷰 준비
**인터뷰 프로세스 이해**

코딩 인터뷰는 기술적 능력을 평가하는 중요한 과정입니다. 일반적으로, 인터뷰는 소개, 기술적 문제 풀이, 그리고 질문 시간으로 구성됩니다. 인터뷰어는 당신의 문제 해결 능력, 코드 작성 능력, 그리고 기술적 지식을 평가하고자 합니다. 또한, 팀워크와 커뮤니케이션 능력도 중요한 평가 요소입니다. 인터뷰 과정에서는 문제를 체계적으로 해결하는 방식을 보여주고, 생각하는 과정을 명확하게 전달하는 것이 중요합니다.

![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTVv1Ax3_XKnPdZI-WhFrPT1nNieXEJheo8lg&usqp=CAU)

**자주 나오는 질문 유형**

코딩 인터뷰에서는 다음과 같은 유형의 질문이 자주 나옵니다:

- 자료구조: 배열, 연결 리스트, 스택, 큐, 해시 테이블, 트리, 그래프 등의 기본적인 자료구조에 대한 이해를 평가합니다.
- 알고리즘: 정렬, 탐색, 재귀, 다이나믹 프로그래밍, 그리디 알고리즘 등 다양한 알고리즘 문제가 제시될 수 있습니다.
- 시스템 디자인: 대규모 시스템을 설계하는 방법에 대한 질문으로, 아키텍처 설계, 스케일링, 데이터 모델링 등을 평가합니다.

예제 문제로는 "정렬되지 않은 배열에서 중복 요소 찾기", "이진 트리의 깊이 구하기", "주어진 합계를 만족하는 배열 내 두 숫자 찾기" 등이 있습니다.

**문제 해결 전략**

문제 해결 전략을 개발하고, 이를 효과적으로 전달하는 것이 중요합니다. 다음은 몇 가지 유용한 전략입니다:

- 천천히 그리고 명확하게 문제 이해하기: 문제를 철저히 이해했는지 확인하고, 필요하다면 질문하여 명확히 합니다.
예제를 통해 문제 해결하기: 간단한 예제를 사용하여 문제를 해결하는 방법을 시각화합니다.
- 단계별 접근: 문제를 여러 단계로 나누어 접근하고, 각 단계를 차례대로 해결합니다.
의사 코드 사용: 복잡한 문제를 해결할 때 의사 코드를 작성하여 로직을 구성합니다.
- 코드 작성: 의사 코드를 기반으로 실제 코드를 작성합니다. 작성하는 동안, 코드를 간결하고 가독성 있게 유지하려고 노력합니다.
- 테스트 케이스 실행: 문제를 해결한 후, 다양한 테스트 케이스를 사용하여 솔루션을 검증합니다.
- 솔루션 설명: 당신의 생각 과정과 해결책을 분명하고 자신 있게 설명합니다.
이러한 전략들은 코딩 인터뷰에서 문제를 효과적으로 접근하고 해결하는 데 도움이 됩니다. 또한, 인터뷰 중에는 자신감을 유지하고, 당황하지 않으며, 모르는 것이 있으면 질문하는 것이 중요합니다. 인터뷰 과정은 단지 기술적 능력만을 평가하는 것이 아니라, 문제를 해결하는 과정에서의 당신의 태도와 접근 방식도 평가하는 시간입니다.

### 알고리즘 대회 준비

**대회 유형과 포맷**

알고리즘 대회는 참가자의 코딩 능력, 알고리즘 지식, 문제 해결 능력을 시험하는 경연입니다. 대회는 크게 온라인과 오프라인으로 나뉘며, 각각의 대회는 다음과 같은 특징을 가집니다:

- 온라인 대회: Codeforces, LeetCode, HackerRank 등 다양한 온라인 플랫폼에서 주최합니다. 참가자는 전 세계 어디에서나 인터넷을 통해 참여할 수 있습니다.
- 오프라인 대회: ACM ICPC, Google Code Jam, Facebook Hacker Cup과 같은 대회는 대면으로 진행되며, 보통 팀 단위로 참가합니다.

대회 포맷은 대회마다 다르지만, 일반적으로는 제한된 시간 안에 여러 문제를 해결해야 하는 형식입니다. 문제는 간단한 구현부터 복잡한 알고리즘 및 자료구조를 요구하는 문제까지 다양합니다.

![](https://www.hanbit.co.kr/data/editor/20200918163925_xyypndmo.png)

**훈련과 준비 방법**

알고리즘 대회를 위한 훈련은 지속적이고 체계적인 접근이 필요합니다:

- 기본기 강화: 자료구조와 알고리즘의 기본 개념을 확실히 이해하고, 다양한 문제를 통해 실습합니다.
- 문제 풀이 연습: 온라인 저지 시스템을 이용해 다양한 유형의 문제를 지속적으로 풀어보며 실력을 쌓습니다.
- 과거 대회 문제 풀이: 과거에 진행된 대회의 문제를 풀어보며, 대회의 유형과 난이도에 익숙해집니다.
- 모의 대회 참가: 실제 대회와 유사한 환경에서 모의 대회에 참가하여 실전 감각을 키웁니다.

**시간 관리와 전략**
제한된 시간 안에 최대한 많은 문제를 정확하게 해결하는 것이 중요합니다:

- 문제 선택: 모든 문제를 빠르게 훑어보고, 자신 있는 문제부터 해결하는 전략을 세웁니다.
- 시간 할당: 각 문제에 너무 많은 시간을 투자하지 않도록 주의하며, 일정 시간이 지나도록 문제가 해결되지 않으면 다른 문제로 넘어갑니다.
- 디버깅 시간 고려: 문제를 해결한 후에는 답안을 검토하고 디버깅하는 시간을 충분히 가질 수 있도록 시간을 관리합니다.

알고리즘 대회 준비는 단기간에 이루어지는 것이 아니며, 꾸준한 연습과 경험이 중요합니다. 기본 개념을 확실히 이해하고, 다양한 문제를 통해 문제 해결 능력을 키우며, 실전에서의 시간 관리 능력을 개발하는 것이 성공적인 대회 참가의 열쇠입니다.

### 실전 문제 풀이와 분석

실전 문제 풀이와 분석은 알고리즘 학습 과정에서 중요한 단계입니다. 이 과정을 통해 이론적 지식을 실제 문제에 적용하고, 다양한 문제 해결 전략과 기술을 익힐 수 있습니다.

**실전 문제 풀이**

- 다양한 난이도의 문제: 초급부터 고급까지 다양한 난이도의 문제를 풀어봄으로써, 다양한 문제에 대한 접근 방법과 해결 전략을 배웁니다.
- 접근 방법과 해설 제공: 각 문제에 대해 문제 해결을 위한 접근 방법을 단계별로 설명하고, 상세한 해설을 제공하여 학습자가 문제 해결 과정을 이해할 수 있도록 돕습니다.
- 실전 연습: 실제 코딩 인터뷰나 알고리즘 대회와 유사한 환경에서 문제를 풀어보며, 시간 관리 및 스트레스 관리 능력을 키울 수 있습니다.


**온라인 저지 사이트**
- [백준](https://www.acmicpc.net/)
- [프로그래머스](https://programmers.co.kr/)
- [정올](https://www.jungol.co.kr/)
- [SWEA](https://swexpertacademy.com/main/main.do)
- [소프티어](https://softeer.ai/)

**문제 분석**

- 중요한 결정 식별: 문제를 해결하는 과정에서 내린 중요한 결정들을 식별하고, 왜 그러한 결정을 내렸는지 분석합니다.
- 다양한 접근 방법 비교: 한 문제에 대해 여러 가지 다른 접근 방법을 시도해보고, 각 접근 방법의 장단점을 비교합니다.
- 패턴 인식: 여러 문제를 풀어보면서 비슷한 유형의 문제나 반복되는 패턴을 인식하고, 이를 빠르게 해결할 수 있는 방법을 개발합니다.

**최적화와 리팩토링**
- 초기 해결책에서 출발: 가장 간단하거나 직관적인 해결책에서 시작하여, 문제를 해결합니다.
- 성능 분석: 초기 해결책의 성능을 분석하고, 성능 병목이나 비효율적인 부분을 식별합니다.
- 점진적 개선: 성능을 개선하기 위해 알고리즘을 최적화하고, 코드를 리팩토링하여 가독성과 유지 보수성을 향상시킵니다. 예를 들어, 불필요한 계산을 제거하거나, 더 효율적인 자료구조를 사용하는 등의 방법을 적용할 수 있습니다.

실전 문제 풀이와 분석 과정은 알고리즘과 프로그래밍 실력을 체계적으로 향상시키는 데 매우 중요합니다. 이 과정을 통해 학습자는 단순히 문제를 해결하는 방법뿐만 아니라, 문제를 깊이 있게 분석하고, 효율적이고 유지 보수가 용이한 코드를 작성하는 방법을 배우게 됩니다.

### 실전 팁과 자주 만나는 문제 유형

**효과적인 연습 방법**

실력 향상을 위한 연습은 단순히 문제를 많이 푸는 것 이상의 전략이 필요합니다:

- 타겟 연습: 자신의 약점을 파악하고, 그 부분을 집중적으로 강화합니다. 예를 들어, 동적 프로그래밍이나 그래프 이론에 어려움을 느낀다면, 해당 주제에 관련된 문제를 더 많이 풀어보세요.
- 코드 리뷰: 다른 사람의 코드를 읽고 분석함으로써 다양한 해결 방법과 코딩 스타일을 배울 수 있습니다. 또한, 자신의 코드를 다른 사람에게 설명하는 과정에서 문제 해결 방법을 명확히 할 수 있습니다.
- 알고리즘 개념 학습: 문제를 풀기 전에 관련된 알고리즘 이론과 개념을 충분히 이해하고, 이를 적용하는 방법을 연습합니다.

**자주 만나는 문제 유형**

코딩 인터뷰나 알고리즘 대회에서는 특정 유형의 문제가 자주 출제됩니다. 이러한 문제 유형에 익숙해지고, 각 유형에 대한 해결 전략을 개발하는 것이 중요합니다:

- 배열과 문자열: 순환, 정렬, 탐색, 압축, 회전 등과 같은 기본적인 배열과 문자열 조작 문제
- 자료구조: 스택, 큐, 연결 리스트, 트리, 그래프, 해시 테이블을 사용하는 문제
- 알고리즘: 이진 탐색, 정렬 알고리즘, 재귀, 다이나믹 프로그래밍, 그리디 알고리즘, 백트래킹 등의 알고리즘을 적용하는 문제
- 수학 및 논리 문제: 소수, 최대공약수, 비트 조작, 확률 문제 등 수학적 개념을 적용해야 하는 문제
- 시스템 디자인: 대규모 시스템을 설계하고, 성능, 확장성, 안정성 등을 고려해야 하는 문제

![](https://velog.velcdn.com/images/yellow372/post/02a7ed9a-4041-42fe-a318-d77719598537/image.png)
[SUAPC 알고리즘 정리](https://velog.io/@yellow372/SUAPC-%EB%8C%80%EB%B9%84-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A6%AC)

**스트레스 관리**
고압적인 환경에서는 스트레스 관리가 성공의 열쇠가 될 수 있습니다:

- 준비된 마음가짐: 충분한 준비와 연습을 통해 자신감을 갖는 것이 중요합니다. 준비 과정 자체가 스트레스를 줄이는 데 도움이 될 수 있습니다.
- 시간 관리: 시간을 효율적으로 관리하여, 문제에 대한 과도한 고민으로 시간을 낭비하지 않도록 합니다. 각 문제에 충분한 시간을 할당하고, 시간이 지나도 해결되지 않는다면 다음 문제로 넘어가세요.
- 긍정적인 태도 유지: 모든 문제를 해결하지 못할 수도 있음을 받아들이고, 최선을 다하는 것에 집중하세요. 실패를 학습의 기회로 삼고, 다음에 더 잘할 수 있도록 노력하세요.

![](https://csp.kohi.or.kr/data/upload/bbs/2021/3/23/021db1ec-df98-456f-aec8-cecfb9e52f39.jpg)

실전 팁과 자주 만나는 문제 유형에 대한 이해는 코딩 인터뷰와 알고리즘 대회에서 성공적인 성과를 거두는 데 필수적입니다. 체계적인 준비와 연습, 그리고 긍정적인 마인드셋을 유지함으로써 어려운 문제에도 효과적으로 대응할 수 있습니다.

### 📍부록 및 참고 자료

- [알고리즘](https://www.gklibrarykor.com/1395/)
- [알고리즘 설계 기법](https://blog.naver.com/PostView.nhn?blogId=jvioonpe&logNo=220234068594)
- [컴퓨팅 사고력 요소](https://blog.naver.com/logibrothers/221537446041)